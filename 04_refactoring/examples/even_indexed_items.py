#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# this collection of refactors was generated by Claude
#  not all of these are good practice!  This was Claud's prompt:
#  -> please include only unconventional solutions - minimized, confusingly clever, funny, punny, obfuscated, ... show the diversity of possibilities

#  =====  describe your function's behavior with a docstring  =====

"""Filters a list, keeping only elements at even-indexed positions.

Arguments:
    items - a list of any type of elements, defaults to empty list

Returns: list - containing only the elements from even-indexed positions (0, 2, 4, etc.)

Raises:
    AssertionError - if the argument is not a list

Examples:

>>> even_indexed_items([])
[]

>>> even_indexed_items([1, 2, 3, 4, 5])
[1, 3, 5]

>>> even_indexed_items(['a', 'b', 'c', 'd', 'e', 'f'])
['a', 'c', 'e']

"""


# ===== import dependencies =====

import traceback
import functools
import itertools
from typing import List, TypeVar, Any

T = TypeVar("T")


#  =====  write and refactor your solutions  =====


# Standard solution as reference point
def even_indexed_items(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    result = []
    for i in range(0, len(items), 2):
        result.append(items[i])

    return result


# Overly compact, one-liner with list comprehension
def one_liner_madness(l: List[T] = None) -> List[T]:
    return (
        [l[i] for i in range(0, len(l if l is not None else []), 2)]
        if isinstance(l if l is not None else [], list)
        else (_ for _ in ()).throw(AssertionError("argument must be a list"))
    )


# Using advanced slicing
def slice_of_life(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    return items[::2]


# Using bitwise operations to check for even indices
def bit_by_bit(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    return [item for idx, item in enumerate(items) if not (idx & 1)]


# Using recursive approach with head/tail pattern
def head_over_heels(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    if not items:
        return []
    return [items[0]] + (head_over_heels(items[2:]) if len(items) > 1 else [])


# Using filter with a lambda that checks item position
def filtered_perspective(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    return list(itertools.compress(items, itertools.cycle([1, 0])))


# Using reduce - overly complicated
def reduce_to_tears(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    return functools.reduce(
        lambda acc, x: acc + [x[1]] if x[0] % 2 == 0 else acc, enumerate(items), []
    )


# Using map and zip with unpacking - confusing but clever
def zip_zap_zoom(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    evens = items[::2]
    odds = items[1::2]
    # Reconstructs original list in pairs, then extracts first items
    return [
        x for x, *_ in zip(evens, odds if len(odds) == len(evens) else odds + [None])
    ]


# Taking the scenic route with dictionary comprehension
def dictator_for_life(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    # Create a dictionary with positions as keys, then filter
    return list({i: item for i, item in enumerate(items) if i % 2 == 0}.values())


# Extremely obfuscated using ASCII manipulation
def ascii_art(items: List[Any] = None) -> List[Any]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    return [
        items[i]
        for i in range(len(items))
        if ord("0") % (ord("2") - ord("0")) == i % (ord("2") - ord("0"))
    ]


# Using exec to dynamically create the solution
def exec_utioner(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    result = []
    exec("for i in range(0, len(items), 2): result.append(items[i])")
    return result


# Multiple dispatch with nested functions
def matryoshka_doll(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    def inner_doll(lst, idx=0, result=None):
        if result is None:
            result = []
        if idx >= len(lst):
            return result
        return inner_doll(lst, idx + 2, result + [lst[idx]])

    return inner_doll(items)


# Using binary representation of indices
def binary_bliss(items: List[T] = None) -> List[T]:
    if items is None:
        items = []
    assert isinstance(items, list), "argument must be a list"

    return [item for idx, item in enumerate(items) if bin(idx)[-1] == "0"]


#  =====  test your solutions  =====


# --- write your function names in this list ---
for solution in [
    even_indexed_items,
    one_liner_madness,
    slice_of_life,
    bit_by_bit,
    head_over_heels,
    filtered_perspective,
    reduce_to_tears,
    zip_zap_zoom,
    dictator_for_life,
    ascii_art,
    exec_utioner,
    matryoshka_doll,
    binary_bliss,
]:
    print(f"\n{solution.__name__} ... ", end="")

    try:
        # ---BEGIN assertion tests ---

        assert solution() == []
        assert solution([]) == []
        assert solution([1]) == [1]
        assert solution([1, 2]) == [1]
        assert solution([1, 2, 3]) == [1, 3]
        assert solution([1, 2, 3, 4]) == [1, 3]
        assert solution([1, 2, 3, 4, 5]) == [1, 3, 5]
        assert solution(["a", "b", "c", "d", "e", "f"]) == ["a", "c", "e"]
        assert solution([True, False, True, False, True]) == [True, True, True]
        assert solution([[1], [2, 3], [4, 5, 6], [7, 8]]) == [[1], [4, 5, 6]]

        # ---END assertion tests ---

        print("√")

    except AssertionError:
        print("χ -- test case failure --", "\n")
        traceback.print_exc()

    except Exception as e:
        print("χ -- error --", "\n")
        print("An error occurred:", e)
        traceback.print_exc()

print("\n--- all done ---")
